import { Observable } from 'rxjs';
/**
 * Query cache options
 */
export interface QueryCacheOptions<TParams> {
    /**
     * parameters passed to create observable.
     */
    params?: TParams;
    /**
     * interval with milliseconds to make auto background query.
     */
    interval?: number;
    /**
     * enable recovery capability.
     * caller should clean up environment by calling clearCache() when finished to use the instance of query cache.
     */
    enableRecovery?: boolean;
    /**
     * enable delaying clean up of observable after all subscriptions were unsubscribed.
     */
    delayClean?: boolean;
}
/**
 * Function to create a new observable with specified parameters.
 */
export interface QueryCacheCreator<TData, TParams> {
    (param: TParams): Observable<TData>;
}
/**
 * Function to generate serialized string from specified parameters.
 */
export interface QueryCacheSerializeParams<TParams> {
    (param: TParams): string;
}
/**
 * Function to destroy any remained condition to clear up.
 */
export interface QueryCacheDestroy {
    (): void;
}
/**
 * Query Cache class.
 * - Create a cache entry by "create" call with creator object.
 * - Subscribe with options to get query result.
 * - Refresh data on-demand and interval.
 * - Dispose the resource when it's done.
 * - Recover and re-subscribe with the same handlers if necessary after an error.
 *
 * TData the data type of observable responds.
 * TParams the options parameters to pass the creator to create new observable.
 */
export declare class QueryCache<TData, TParams> {
    private create;
    private serializeParams;
    private destroy;
    /**
     * Delay clean up time (10 seconds)
     */
    private static delayTime;
    /**
     * Cached data collection with observable ReplaySubject.
     */
    private cachedData;
    /**
     * Current options, passed from the fetch call.
     */
    private options;
    /**
     * Key string serialized by TParams.
     */
    private key;
    /**
     * Delay clean timer object.
     */
    private delayTimer;
    /**
     * Auto fetch options.
     */
    private autoFetchOptions;
    /**
     * Initializes a new instance of the QueryCache.
     *
     * @param create the function to create a new observable with specified parameters.
     * @param serializeParams the function to generate serialized string from specified parameters. (optional)
     * @param destroy the function to clean up any residue after all reference was gone. (optional)
     */
    constructor(create: QueryCacheCreator<TData, TParams>, serializeParams?: QueryCacheSerializeParams<TParams>, destroy?: QueryCacheDestroy);
    /**
     * Create or return the cached observable.
     *
     * @param autoFetchOptions the options parameter auto-fetch when subscribe is called.
     * @return Observable<TData> the observable object.
     */
    createObservable(autoFetchOptions?: QueryCacheOptions<TParams>): Observable<TData>;
    /**
     * Unsubscribe any remained subscribers and dispose all remained resources.
     * - clearCache() is not necessary to be called if all subscriptions are unsubscribe'ed properly.
     */
    clearCache(): void;
    /**
     * Fetch with new query options.
     * - The fetch starts new query when cache is empty, current cache doesn't match the key generated by
     *   serializedParams function which was configured at the constructor, interval was changed (ex.
     *   changing zero interval to active interval or other way around), or the first subscriber like when
     *   delayClean comes back active subscription.
     *
     * @param options the options with interval, delay clean, recovery and parameters.
     */
    fetch(options: QueryCacheOptions<TParams>): void;
    /**
     * Refresh the query cache with last options and parameters provided on the fetch call.
     */
    refresh(): void;
    /**
     * Recover the observable and subscription.
     * - Recover can be used to resubscribe when the observable got any error situation. The observable would
     *   be unsubscribed state when it got an error response, this function allows to resubscribe without
     *   recreate observable and subscription.
     *
     * @param autoFetch if true auto fetch after re-subscribed.
     */
    recover(autoFetch: boolean): void;
    /**
     * Apply instant data to the query cache. The data will be delivered to the subscriber immediately.
     *
     * @param data the data to apply to the replay.
     */
    apply(data: TData): void;
    private createPublishObservable(fetch, refresh, apply, subscribers);
    private internalUnsubscribe(context);
    private cleanup(recovery);
}
